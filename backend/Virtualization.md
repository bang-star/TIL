# 클라우드, 가상화, 컨테이너 정리

## 1. 가상화

### 1-1. 가상화 개념

```
가상화가 등장하기 이전에 기업의 전통적인 방식은 하나의 서버에 하나의 운영체제, 하나의 프로그램을 운영하여 각 서버가 갖고 있는 시스템 자원 중 약 50~70% 정도만 사용할 수 있었다. 즉, 물리적 서버가 갖고 있는 성능을 100% 활용해서 사용할 수 없었다. 이 과정에서 기업은 갖고 있는 물리적 서버를 최대한 효율적으로 사용하길 원했고, 각 서버가 100%의 성능을 발휘할 수 있길 원했다. 
 
  즉, 한 대의 물리적인 장비를 마치 여러 대의 장비처럼 활용하거나, 여러 장비를 하나의 장비처럼 묶어서 사용하기를 원했고 이로 인해 등장한 기술이 "가상화"이다.
```
  - 가상화(Virtualization)는 물리적인 컴포넌트(Components, HW장치)를 논리적인 객체로 추상화 하는 것을 의미. 마치 하나의 장치를 여러 개처럼 동작시키거나, 반대로 여러 개의 장치를 묶어 하나의 장치인 것처럼 사용할 수 있는 기술

  - 가상화의 대상이 되는 컴퓨팅 자원은 프로세서(CPU), 메모리(Memory), 스토리지(Storage), 네트워크(Network), 그래픽 처리 장치(GPU)가 있으며, 이들로 구성된 서버나 장치들을 가상화함으로써 높은 수준의 자원 사용률과 분산 처리 능력을 얻을 수 있음

<br />

### 1-2. 가상화 기술의 종류

<br />

#### (1) 서버 가상화(Server Virtualization)
    
  - 가상화 개념의 시초
    
  - 가상화를 가능하게 하는 하이퍼바이저(Hypervisor)와 이 하이퍼바이저를 통해 제어되며, 각종 어플리케이션을 실행하기 위한 환경인 가상머신(Virtual Machine, VM)으로 이루어진다.
    
  - 하드웨어를 가상화하기 위해서는 하드웨어뿐만 아니라 각각의 가상머신들을 관리할 가상머신모니터(VMM: Virtual Machine Monitor)와 같은 중간 관리자가 필요한데 이를 하이퍼바이저라고 하며 VM이 동작할 수 있는 환경을 제공한다.

<br />

#### (2) 데스크탑 가상화 (Virtual Desktop Infrastructure, VDI)

  - 데이터 센터의 서버에서 운영되는 가상의 PC 환경을 의미

  - ​물리적으로는 존재하지 않는 가상의 개별 컴퓨터로 사용자는 모니터, 키보드, 마우스, 스피커 등의 필수적인 입출력 장치만을 활용하거나 매우 단순화된 인터페이스만 가지고 컴퓨터를 활용할 수 있음

  - ​가상의 데스크탑을 마치 로컬 시스템처럼 활용할 수 있으며, 모든 작업의 프로세싱과 저장은 데이터 센터에 위치한 서버에서 처리됨

  - VDI 환경에서는 언제 어디서든 네트워크만 연결이 된다면 서버에 접속하여 자신만의 PC환경을 구동시킬 수 있음. 사용자는 보통의 PC보다 5~10% 수준의 전력 소모만으로도 유사한 컴퓨팅 환경을 구현

  - 데이터가 로컬 장치가 아닌 서버에 위치하기 때문에 복원, 생성 등의 작업이 쉬워지며, 보안 측면에서도 데이터 센터급의 서비스를 보장받을 수 있음


 #### (3) 애플리케이션 가상화 (Application Virtualization)

  - 해당 응용 프로그램이 실행되는 운영체제로부터 응용 소프트웨어를 캡슐화하는 기법

  - 캡슐화는 한 응용 프로그램이 업데이트됨에 따라 관련된 다른 응용프로그램이 동작하지 않는 부작용을 방지. 따라서 애플리케이션 관리가 수천 개에 달하는 기업의 경우, 가상화된 애플리케이션은 관리자가 배포 및 업데이트를 할 때 상대적으로 유용

  - 컨테이너가 애플리케이션 가상화를 실현한다. 기존의 VM은 컴퓨팅 인프라, 즉 서버의 가상화를 지원하는 반면, 컨테이너는 소프트웨어 애플리케이션의 가상화를 지원한다. 가상 시스템과 달리 컨테이너는 자체 운영 체제를 제공하지 않고 호스트의 OS(운영 체제)를 이용한다.
 

<br />
<hr />
<br />

## 2. 유틸리티 컴퓨팅

```
가상화 도입으로 기업은 상대적으로 저렴한 비용을 들이면서 성능을 구현할 수 있게 됐다. 그러나 가상화 구축은 여전히 물리적 서버를 구매해야 했고, 이 때 인터넷데이터센터(IDC)를 보유한 기업들은 자신들의 데이터센터를 다른 기업에 빌려주는 유틸리티 컴퓨팅 서비스를 제공했다.
```

  - 유틸리티 컴퓨팅 (Utility Computing)이란 기업이 IT 시스템을 직접 구축하지 않고 하드웨어, 소프트웨어, 기업용 솔루션, 네트워크 서비스 등의 IT 서비스를 필요할 때마다 전기나 수도처럼 빌려서 사용하고 사용량에 따라 요금을 지불하는것을 의미한다. 서비스를 제공하는 업체가 다양한 ‘시스템 풀(Pool)’을 만들어 놓으면 기업이 그 때마다 필요에 의해 연결하여 사용할수 있다. 다만, 시스템 풀에서 제공되는 IT시스템이 완벽하게 기업의 요구 조건을 만족시킬 수는 없기 때문에 기업의 요구조건에 맞게 일부 수정이 필요하다. 

    > * IDC는 ‘인터넷 데이터 센터’(Internet Data Center)의 준말로, 인터넷(Internet) 연결의 핵심이 되는 서버(Server)를 한 데 모아 집중시킬 필요가 있을 때 설립하는 시설을 말한다. IDC를 통해 온라인 게임의 운영에 필요한 서버 컴퓨터(Server Computer)와 네트워크(Network) 회선 등을 제공하는데, 다른 말로는 서버 호텔(Server Hotel)이라고도 부른다.

<br />
<hr />
<br />

## 3. 클라우딩 컴퓨팅

```
과거 1980년대 전후하여 원격지에 있는 컴퓨터와 근처에 있는 단말기 사이에 있는 수 많은 통신장비 및 네트워크를 다 그리지 않고 구름 모양을 그려서 설명을 하였다. 이후 2000년대에 클라우드 컴퓨팅이 등장하면서 이 개념을 설명하기가 애매하여 이 구름 개념을 따 와서 구름(cloud)이라고 한 것이 클라우드다.

즉, 클라우드의 의미는 컴퓨터 통신망이 복잡한 네트워크 및 서버 구성 등을 알 필요 없이 구름과 같이 내부가 보이지 않고, 일반 사용자는 이 복잡한 내부를 굳이 알 필요도 없이 어디에서나 구름 속의 컴퓨터 자원으로 자기가 원하는 작업을 할 수 있다는 것이다. 이른바 동일한 체험을, 인터넷이 연결된 어디에서나 보장해주는 것이다.

2019년 조사에 따르면 800개 기업 중 94%가 클라우드 컴퓨팅을 사용하고 있었으며, 2021년까지 전체 클라우드 인프라를 사용하는 기업은 절반 이상이 될 전망이다.
출처 : 나무위키
```

  - 클라우드 컴퓨팅은 기존의 하드웨어와 이들을 연결하는 네트워크로 구성된 환경을 가상화를 통해 통합된 계산, 저장 및 처리가 가능한 환경으로 제공하는 것으로 정의할 수 있다. 실제 하드웨어의 물리적인 레이어를 가상화함으로써, 데이터센터가 제공할 수 있는 다양한 기능들을 가진 ‘가상의 데이터센터’를 구현할 수 있다.

  - 대부분의 작업을 온라인에 분산되어 존재하는 데이터 센터(Data Center, 이하 클라우드)에 맡겨 수행하고, 사용자의 컴퓨터는 클라우드에 접속하여 상호작용하는 단말기 역할만 하는 것이다. 이 때문에 모든 데이터와 연산 자원이 클라우드 안에만 존재하게 되며, 이 자원을 유연하게 관리하기 위해 가상화 기술 등이 투입되게 된다. 

<br />
<hr />
<br />

## 4. 하이퍼바이저 vs 컨테이너

```
자세한 내용에 들어가기 전에 내 짧은 지식을 이용하여 내 스스로를 이해시키고자 요약을 해보자면
학부 리눅스 수업에서 VMware, VirtualBox같은 하이퍼바이저를 이용하여 흔히들 사용하는 윈도우 서버 위에 Guest OS로 리눅스 서버를 올렸다. 이러한 하이퍼바이저 위에는 OS를 여러개 생성할 수 있었고, 각 OS마다 메모리나 하드디스크를 마음대로 분배할 수 있었다. 그리고 생성된 게스트 OS 중 하나가 뻑나도 다른 OS에 전혀 영향을 미치지 않았다. 즉 하이퍼바이저는 하드웨어 자원을 각각의 게스트 OS에게 분할하여 위에서 설명한 서버 가상화를 완벽하게 구현할 수 있다.

그런데, 이런 서버 가상화가 개발자 입장에서는 매우 불편한 것이다. 소프트웨어를 개발하면 그 소프트웨어를 배포하기 위해서는 Binary파일과 Library파일 등 OS마다 그에 맞는 종속성 문제를 해결해야 한다. 그런데 컨테이너를 사용하면 애플리케이션과 종속 항목을 버전 관리가 쉬운 하나의 패키지로 묶어 팀 내의 여러 개발자가 쉽게 복제하고 클러스터 내의 머신으로도 간편하게 복제되도록 만들 수 있다. 즉, 개발자 입장에서는 시스템 소프트웨어 등 여러 종속성 문제에 구애받지 않고 여러 OS에 애플리케이션을 배포하며 시스템 소프트웨어에 대해서 구애받지 않고 버전관리를 할 수 있다.
```

### 1. 하이퍼바이저

#### 1-1. 하이퍼바이저의 개념

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcsXpPw%2Fbtq21o6Sv9M%2F6D9wTUfT9YtFbqhwr4MyKK%2Fimg.png">

  - 호스트 시스템에서 다수의 게스트 OS를 구동할 수 있게 하는 소프트웨어.

  - 하드웨어를 가상화하면서 하드웨어와 각각의 VM을 모니터링하는 중간 관리자. VMM(Virtual Machine Monitor)이라고도 불림.

    > VM은 기본적으로 컴퓨터의 에뮬레이션으로, 프로그램을 실제 컴퓨터처럼 실행한다. VM들은 “하이퍼바이저”를 통해 물리적 기계(machine) 위에서 돌아간다. 

<br />

#### 1-2. 하이퍼바이저의 종류

<br />

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcgvOp3%2Fbtq22bTw77l%2F7QrESMEEJa3iFOPfgmssRk%2Fimg.png">

<br />

  - Type1 하이퍼바이저 :  베어메탈(Bare-metal)기반

    하이퍼바이저가 하드웨어 바로 위에서 실행되는 방식이다. 하이퍼바이저가 하드웨어를 직접 제어하기 때문에 자원을 효율적으로 사용할 수 있고, 별도의 호스트OS가 없으므로 오버헤드가 적지만 여러 하드웨어 드라이버를 세팅해야 하므로 설치가 어렵다.

    예) Xen, 마이크로소프트 Hyper-V, KVM

  - Type2 하이퍼바이저 : 호스트(Host) 기반
    
    Type2는 하드웨어 위에 호스트 운영체제(Host OS)가 있고, 그 위에서 하이퍼바이저가 다른 응용프로그램과 유사한 형태로 동작한다. 이 타입의 하이퍼바이저에 의해서 관장되는 가상머신의 게스트OS는 하드웨어 위에서 3번째 수준으로 구동된다. 기존의 컴퓨터 환경에서 하이퍼바이저를 활용하는 것이기에 설치가 용이하고 구성이 편리한 장점이 있다. 반면, Type1 보다는 성능이 떨어질 수 있다

    예) VMware server, VMware Workstation, Virtual box

<br />

#### 1-3. 하이퍼바이저의 특징

<br />

 - 장점

    - 하이퍼바이저에 의해 구동되는 VM은 각 VM마다 독립된 가상 하드웨어 자원을 할당받는다. 즉, 각 VM마다 논리적으로 분리되어 있어서 한 VM에 오류가 발생해도 다른 VM으로 퍼지지 않는다.

 - 단점

    1. 완전한 운영체제가 설치되기 때문에 대량의 메모리가 필요하다.

        우분투 리눅스 서버를 올리려고 할 때, 메모리상에 로드되는 내용만해도 500MB 정도가 소모된다. 예를 들어, 가상머신 10개에 똑같이 우분투 리눅스 서버를 올리려고 할 때, 5GB 정도의 메모리가 사용될 수 있다. 물리적인 메모리의 양이 작은 경우 쓰레싱(Thrashing)을 초래해서 성능 저하가 발생할 수도 있다.

 

    2. CPU 성능 확보에 대한 문제가 있다.

        서로다른 애플리케이션이 CPU 자원에 대한 요청을 할 때 CPU 자원에 대한 경쟁이 발생하게 된다. 이 때, 우선순위 등을 주어서 운영체제 내에서는 효율적으로 관리를 할 수 있지만 가상화된 CPU가 실제 물리 CPU를 어떻게 얻을지는 정해지지 않았다. 예를 들어 1번 게스트 OS에 서 우선순위가 높다고 해도, 게스트 운영체제 자체가 우선순위가 낮다면 물리적인 CPU 자원을 확보하는게 쉽지 않을 수 있다.

        이와 같은 원인으로 CPU 자원 경쟁에 따른 성능저하가 있을 수 있다. 가상화 서비스에서는 이런 문제를 해결하기위해 Dedicate 서비스를 제공한다. 즉, CPU 같은 물리적인 자원을 특정 게스트 운영체제에게 전담배치시키는 서비스이다.

 

    3. 시스템 운영에 대한 통합적인 지식이 필요하다.

        일반적인 시스템에서는 소프트웨어 개발과 시스템 운영이 분리가 되어 있었다. 하지만 가상머신체제에서는 이미 만들어진 시스템 위에 새로운 시스템을 구축하는 개념이기 때문에 통합적인 시스템 운영 지식과 소프트웨어 개발 지식이 통합 관리되어야하는 부담이 있다.

<br />

### 2. 컨테이너

#### 2-1 컨테이너란

<br />

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FKMvK4%2Fbtq26HqaYg8%2F611iZkDaemjmk0Nk1lVlz1%2Fimg.png">

<br />

```
클라우드 컴퓨팅에서 컨테이너는 어플리케이션(App)과 App을 구동하는 환경을 격리한 공간을 의미한다. 가상화의 범주 내에서 컨테이너는 기존 하이퍼바이저와 게스트OS를 필요로 했던 가상머신 방식과는 달리, 프로세스를 격리하여‘모듈화된 프로그램 패키지’로써 수행하는 것을 의미한다

컨테이너라는 개념이 처음 등장한 것은 2000년대 중반부터 리눅스에 내장된 LXC(LinuX Container)기술로 소개되면서부터이다. 컨테이너 기술이 등장하게 된 계기는 개발한 프로그램이 구동환경의 달라짐에 따라 예상하지 못한 각종 오류를 발생시키는 것을 해결하기 위함이었다. 이 문제는 SW개발자의 오랜 골칫거리였는데, 이런 오류가 발생하는 이유는 구동 환경마다 네트워크, 스토리지, 보안 등의 정책이 각각 다를 수 있기 때문이다. 결국 SW를 하나의 컴퓨팅 환경에서 다른 컴퓨팅 환경으로 이동하더라도 안정적으로 실행하는 방법을 모색하여 나온 방법이 바로 컨테이너이다.

어플리케이션의 실행에 필요한 라이브러리(Library, Libs), 바이너리(Binary, Bins), 기타 구성파일 등을 패키지로 묶어서 배포하면, 구동환경이 바뀌어도 실행에 필요한 파일이 함께 따라다니기 때문에 오류를 최소화할 수 있다
```

컨테이너도 VM처럼 프로세싱을 위한 별도의 공간(private space), 루트 권한, 사설 네트워크, IP 주소, 커스텀 라우트, iptable 규칙, 파일 시스템 마운트 등의 기능을 갖추고 있지만 컨테이너는 호스트 시스템의 커널을 다른 컨테이너들과 공유한다는 점에서 크게 차이가 난다.

<br />

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fds17xw%2Fbtq27ijpbIg%2FFpK4kkxroNrRYrRA473IC0%2Fimg.png">

<br />

이 그림에서 볼 수 있듯이, 컨테이너는 유저 공간만을 포함하고, VM에는 포함되는 커널이나 버추얼 하드웨어가 포함되지 않는다. 여러개의 컨테이너가 하나의 호스트 머신에서 돌아갈 수 있도록 각 컨테이너는 자신만의 격리된 유저 공간을 가지고 있다. 즉, 운영체제 단계의 아키텍처를 모든 컨테이너가 공유하고 있는 것이다. 처음부터 새로 생성되는 부분은 bins와 libs 뿐이며, 이것이 컨테이너가 한결 가벼워질 수 있는 이유이다.


<br />

#### 2-2 컨테이너 기술의 특징

 - 장점
    
    1. 시스템의 성능 부하가 훨씬 적다.

        컨테이너의 경우 생성 및 실행되면 마치 운영체제 위에서 하나의 어플리케이션이 동작하는 것과 동일한 수준의 컴퓨팅 자원을 필요로 한다. 시스템은 기존 응용프로그램을 실행시키는 것과 유사하게 이를 구동할 여분의 컴퓨팅 자원만 있으면 된다

 
    2. 자원에 대한 배분도 좀 더 유연하다.

        컨테이너에서 실행중인 서비스에 더 많은 가용성이 필요하거나 반대로 필요 없을 때, CPU에 대한 사용량이나 사용자가 설정한 임계치에 따라 자동으로 확장 또는 축소가 가능하다.

    3. 구동 방식이 간단하다.
    
        특정 클라우드 어플리케이션이 실행되기 위한 모든 라이브러리와 바이너리파일 등이 패키지화되어 있어서, 그저 기존의 시스템에서 실행하면 된다. 반면, 가상머신 방식은 새로운 서비스를 제공하기 위한 특정 어플리케이션을 실행시키려면, 먼저 새로운 VM을 띄우고 자원을 (- 동적 또는 미리 세팅한 대로) 할당한 다음, 필요한 게스트OS를 부팅한 후 어플리케이션을 실행시켜야 한다.

  - 단점

    1. 자원의 격리와 쿼터 제한이 어렵다
        
        가상머신은 가상 하드웨어를 직접 제어할 수 있기 때문에 높은 수준의 자원 격리와 쿼터 제한을 수행 할 수 있다.
    
        컨테이너의 경우 가상 하드웨어를 두고 있지 않기 때문에 격리 수준과 쿼터 제한이 가상 머신에 비해 떨어질 수 밖에 없다. 하지만 컨테이너 서비스 플랫폼들의 격리 기술과 쿼터 제한 기술이 발전하고 있기는 하다.

    2. 호스트 운영체제에 실행 환경이 묶인다.
        
        컨테이너는 호스트 운영체제의 커널을 공유하기 때문에 호스트 운영체제 환경을 그대로 가져갈 수 밖에 없다. 예를 들어, 리눅스에 컨테이너를 띄워서 윈도우즈 실행 환경을 만들 수 없다는 말이다.

        컨테이너 서비스에 이와 같은 장 단점이 존재한다. 하지만 클라우드 서비스 환경에서 컨테이너 기술을 사용하는 것이 가상머신을 사용하는 것에 비해 얻을 수 있는 장점이 압도적이기 때문에 많이 사용되고 있다.

<br />
<hr />
<br />

## Refer

 - [클라우드, 가상화, 컨테이너 정리](https://hiaurea.tistory.com/53)